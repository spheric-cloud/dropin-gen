// SPDX-FileCopyrightText: 2025 Axel Christ and Spheric contributors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"iter"
	"log/slog"
	"maps"
	"os"
	"path"
	"path/filepath"
	"slices"
	"strconv"
	"strings"

	"github.com/spf13/pflag"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

type TypeParameterized interface {
	TypeParams() *types.TypeParamList
}

func addTypeUsedNames(names map[string]struct{}, typ types.Type) {
	if parameterized, ok := typ.(TypeParameterized); ok {
		if typeParams := parameterized.TypeParams(); typeParams != nil {
			for typeParam := range typeParams.TypeParams() {
				names[typeParam.Obj().Name()] = struct{}{}

				addTypeUsedNames(names, typeParam.Constraint())
			}
		}
	}
}

func addExportUsedNames(names map[string]struct{}, obj types.Object) {
	switch obj := obj.(type) {
	case *types.TypeName:
		addTypeUsedNames(names, obj.Type())
	case *types.Func:
		addTypeUsedNames(names, obj.Type())
		sig := obj.Signature()

		if params := sig.Params(); params != nil {
			for v := range params.Variables() {
				if name := v.Name(); name != "" {
					names[name] = struct{}{}
				}
			}
		}

		if results := sig.Results(); results != nil {
			for v := range results.Variables() {
				if name := v.Name(); name != "" {
					names[name] = struct{}{}
				}
			}
		}
	}
}

func loadPackage(srcDir, path string, filter func(filename string) bool) (*packages.Package, error) {
	parseFile := func(fset *token.FileSet, filename string, src []byte) (*ast.File, error) {
		if filter != nil && !filter(filename) {
			return nil, nil
		}
		return parser.ParseFile(fset, filename, src, parser.AllErrors|parser.ParseComments)
	}

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedImports |
			packages.NeedDeps,
		Dir:       srcDir,
		ParseFile: parseFile,
	}, path)
	if err != nil {
		return nil, err
	}
	for _, pkg := range pkgs {
		if strings.HasSuffix(pkg.Name, "_test") {
			continue
		}

		return pkg, nil
	}
	return nil, fmt.Errorf("expected to find a single non '_test' package, got %v", pkgs)
}

func getSkipExportNames(pkg *packages.Package) map[string]struct{} {
	res := make(map[string]struct{})
	for name := range topLevelExportedObjects(pkg) {
		res[name] = struct{}{}
	}
	return res
}

func generate(
	srcDir string,
	importPath, outputPackage string,
	outputFilename string,
	goHeaderFile string,
) error {
	outputPkg, err := loadPackage(srcDir, outputPackage, func(filename string) bool {
		// Do not load a file generated by us.
		return filepath.Base(filename) != outputFilename
	})
	if err != nil {
		return err
	}

	if outputPkg.Name == "" {
		outputPkg.Name = filepath.Base(outputPkg.PkgPath)
	}

	skipExportNames := getSkipExportNames(outputPkg)

	importPkg, err := loadPackage(srcDir, importPath, nil)
	if err != nil {
		return err
	}

	importExports, err := analyzeExports(importPkg)
	if err != nil {
		return err
	}

	rawDeleg, err := buildDeleg(outputPkg, skipExportNames, importPkg, importExports, goHeaderFile)
	if err != nil {
		return err
	}

	deleg, err := imports.Process(outputFilename, rawDeleg, nil)
	if err != nil {
		return err
	}

	filename := filepath.Join(outputPackage, outputFilename)
	if err := os.MkdirAll(outputPackage, os.ModePerm); err != nil {
		return err
	}

	if err := os.WriteFile(filename, deleg, 0666); err != nil {
		return err
	}

	return nil
}

func buildPkgPathToAlias(pkg *packages.Package, usedNames map[string]struct{}) map[string]string {
	pkgPathToAlias := make(map[string]string)
	for _, imp := range pkg.Imports {
		pkgPathToAlias[imp.PkgPath] = ""
	}

	if _, ok := usedNames[pkg.Name]; !ok {
		pkgPathToAlias[pkg.PkgPath] = ""
		return pkgPathToAlias
	}

	i := 1
	for {
		alias := fmt.Sprintf("%s%d", pkg.Name, i)
		if _, ok := usedNames[alias]; !ok {
			pkgPathToAlias[pkg.PkgPath] = alias
			return pkgPathToAlias
		}

		i++
	}
}

func buildDeleg(
	outputPkg *packages.Package,
	skipExportNames map[string]struct{},
	importPkg *packages.Package,
	importExports *Exports,
	goHeaderFile string,
) ([]byte, error) {
	var buf bytes.Buffer

	if goHeaderFile != "" {
		goHeaderFileData, err := os.ReadFile(goHeaderFile)
		if err != nil {
			return nil, fmt.Errorf("error reading go header file: %w", err)
		}

		buf.Write(goHeaderFileData)
		buf.WriteString("\n")
	}

	// Write the package's doc string if there is any.
	for _, f := range importPkg.Syntax {
		if f.Doc != nil {
			first := true
			for line := range strings.Lines(f.Doc.Text()) {
				buf.WriteString("// ")
				if first {
					first = false
					line = strings.Replace(line, "Package "+importPkg.Name, "Package "+outputPkg.Name, 1)
				}
				buf.WriteString(strings.TrimRight(line, "\n"))
				buf.WriteString("\n")
			}
		}
	}

	buf.WriteString("package ")
	buf.WriteString(outputPkg.Name)
	buf.WriteString("\n\n")

	pkgPathToAlias := buildPkgPathToAlias(importPkg, importExports.UsedNames)

	buf.WriteString("import (\n")

	for pkgPath, alias := range pkgPathToAlias {
		buf.WriteString("\t")
		if alias != "" {
			buf.WriteString(alias)
			buf.WriteString(" ")
		}
		buf.WriteString(strconv.Quote(pkgPath))
		buf.WriteString("\n")
	}
	buf.WriteString(")\n\n")

	qf := adjustingQualifier(importPkg.Types, outputPkg.Types, pkgPathToAlias[importPkg.PkgPath])
	names := slices.Sorted(maps.Keys(importExports.Exports))
	for _, name := range names {
		if _, ok := skipExportNames[name]; ok {
			continue
		}

		importExport := importExports.Exports[name]
		if doc := importExport.Doc.Text(); doc != "" {
			for line := range strings.Lines(doc) {
				buf.WriteString("// ")
				buf.WriteString(strings.TrimRight(line, "\n"))
				buf.WriteString("\n")
			}
		}

		deleg, err := writeDeleg(outputPkg.Types, importExport.TypesObject, qf)
		if err != nil {
			return nil, err
		}

		buf.WriteString(deleg)
		buf.WriteString("\n\n")
	}

	return buf.Bytes(), nil
}

type Export struct {
	TypesObject types.Object
	Doc         *ast.CommentGroup
}

func firstNonNil[E any](e ...*E) *E {
	for _, e := range e {
		if e != nil {
			return e
		}
	}
	return nil
}

func topLevelExportedObjects(pkg *packages.Package) iter.Seq2[string, types.Object] {
	return func(yield func(string, types.Object) bool) {
		for ident, obj := range pkg.TypesInfo.Defs {
			if obj == nil {
				continue
			}

			if !obj.Exported() {
				continue
			}

			// Only include top-level definitions.
			if obj.Parent() != pkg.Types.Scope() {
				continue
			}

			if !yield(ident.Name, obj) {
				return
			}
		}
	}
}

type Exports struct {
	Exports   map[string]*Export
	UsedNames map[string]struct{}
}

func analyzeExports(pkg *packages.Package) (*Exports, error) {
	usedNames := make(map[string]struct{})
	res := make(map[string]*Export)

	// First step: Gather exports by looking at the type information.
	for name, obj := range topLevelExportedObjects(pkg) {
		addExportUsedNames(usedNames, obj)
		res[name] = &Export{
			TypesObject: obj,
		}
	}

	for _, imp := range pkg.Imports {
		if name := path.Base(imp.PkgPath); name != "" {
			usedNames[name] = struct{}{}
		}
	}

	// Next step: Associate the correct documentation to the exports.
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			switch d := decl.(type) {
			case *ast.FuncDecl:
				export, ok := res[d.Name.Name]
				if !ok {
					continue
				}

				export.Doc = d.Doc
			case *ast.GenDecl:
				for _, spec := range d.Specs {
					switch s := spec.(type) {
					case *ast.TypeSpec:
						export, ok := res[s.Name.Name]
						if !ok {
							continue
						}

						export.Doc = firstNonNil(s.Doc, d.Doc)
					case *ast.ValueSpec:
						for _, name := range s.Names {
							export, ok := res[name.Name]
							if !ok {
								continue
							}

							export.Doc = firstNonNil(s.Doc, d.Doc)
						}
					}
				}
			}
		}
	}

	return &Exports{
		Exports:   res,
		UsedNames: usedNames,
	}, nil
}

func writeTypeDeleg(pkg *types.Package, obj *types.TypeName, qf types.Qualifier) (string, error) {
	var sb strings.Builder
	var alias *types.Alias
	if t, ok := obj.Type().(interface{ TypeParams() *types.TypeParamList }); ok && t.TypeParams().Len() > 0 {
		typeParams := make([]*types.TypeParam, 0, t.TypeParams().Len())
		instParams := make([]types.Type, 0, t.TypeParams().Len())

		for tp := range t.TypeParams().TypeParams() {
			aliasTypeParam := tp.Obj().Type()
			typeParams = append(typeParams, types.NewTypeParam(tp.Obj(), tp.Constraint()))
			instParams = append(instParams, aliasTypeParam)
		}

		inst, err := types.Instantiate(nil, obj.Type(), instParams, false)
		if err != nil {
			return "", err
		}

		alias = types.NewAlias(obj, inst)
		alias.SetTypeParams(typeParams)
	} else {
		alias = types.NewAlias(obj, obj.Type())
	}
	aliasType := types.NewTypeName(token.NoPos, nil, obj.Name(), alias)

	sb.WriteString(types.ObjectString(aliasType, qf))
	return sb.String(), nil
}

func writeDeleg(pkg *types.Package, obj types.Object, qf types.Qualifier) (string, error) {
	switch obj := obj.(type) {
	case *types.Func:
		return writeFuncDeleg(pkg, obj, qf)
	case *types.Var:
		return writeVarDeleg(pkg, obj, qf)
	case *types.Const:
		return writeConstDeleg(pkg, obj, qf)
	case *types.TypeName:
		return writeTypeDeleg(pkg, obj, qf)
	default:
		return "", fmt.Errorf("unknown type %T", obj)
	}
}

func writeConstDeleg(pkg *types.Package, obj *types.Const, qf types.Qualifier) (string, error) {
	var sb strings.Builder
	sb.WriteString(types.ObjectString(obj, noQualifier))
	sb.WriteString(" = ")
	sb.WriteString(packagePrefix(obj.Pkg(), qf))
	sb.WriteString(obj.Name())
	return sb.String(), nil
}

func writeVarDeleg(pkg *types.Package, obj *types.Var, qf types.Qualifier) (string, error) {
	var sb strings.Builder
	sb.WriteString(types.ObjectString(obj, noQualifier))
	sb.WriteString(" = ")
	sb.WriteString(packagePrefix(obj.Pkg(), qf))
	sb.WriteString(obj.Name())
	return sb.String(), nil
}

func adjustingQualifier(importPkg, outputPkg *types.Package, importPkgAlias string) types.Qualifier {
	return func(other *types.Package) string {
		if outputPkg != nil && outputPkg == other {
			return "" // same package; unqualified
		}
		if importPkgAlias == "" || other != importPkg {
			return other.Name()
		}
		return importPkgAlias
	}
}

func packagePrefix(pkg *types.Package, qf types.Qualifier) string {
	if pkg == nil {
		return ""
	}
	var s string
	if qf != nil {
		s = qf(pkg)
	} else {
		s = path.Base(pkg.Path())
	}
	if s != "" {
		s += "."
	}
	return s
}

func noQualifier(*types.Package) string {
	return ""
}

func writeFuncDeleg(pkg *types.Package, obj *types.Func, qf types.Qualifier) (string, error) {
	var sb strings.Builder

	delegFunc := types.NewFunc(token.NoPos, pkg, obj.Name(), obj.Signature())

	sb.WriteString(types.ObjectString(delegFunc, qf))
	sb.WriteString(" {\n\t")

	sig := obj.Signature()
	if sig.Results() != nil {
		sb.WriteString("return ")
	}

	sb.WriteString(packagePrefix(obj.Pkg(), qf))
	sb.WriteString(obj.Name())
	sb.WriteString("(")
	if sig.Params() != nil {
		for i := 0; i < sig.Params().Len(); i++ {
			param := sig.Params().At(i)
			if i != 0 {
				sb.WriteString(", ")
			}
			sb.WriteString(param.Name())
			if sig.Variadic() && i == sig.Params().Len()-1 {
				sb.WriteString("...")
			}
		}
	}
	sb.WriteString(")")

	sb.WriteString("\n}")
	return sb.String(), nil
}

func main() {
	var (
		srcDir         string
		importPath     string
		outputPackage  string
		outputFilename string
		goHeaderFile   string
	)

	pflag.StringVar(&srcDir, "src-dir", "", "src-dir is the directory in which to run the build system's query tool\n"+
		"that provides information about the packages.\n"+
		"If src-dir is empty, the tool is run in the current directory.")
	pflag.StringVarP(&importPath, "import-path", "i", "", "Path to the package that shall be examined for creating a dropin from.")
	pflag.StringVarP(&outputPackage, "output-package", "o", "", "Path to the output package that shall be written to.")
	pflag.StringVarP(&outputFilename, "output-filename", "f", "zz_generated.dropin.go", "Name of the output file that shall be written to.")
	pflag.StringVar(&goHeaderFile, "go-header-file", "", "Go header file to include in the generated code.")

	pflag.Parse()

	if importPath == "" || outputPackage == "" || outputFilename == "" {
		pflag.Usage()
		os.Exit(1)
	}

	if err := generate(srcDir, importPath, outputPackage, outputFilename, goHeaderFile); err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
}
