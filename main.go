// SPDX-FileCopyrightText: 2025 Axel Christ and Spheric contributors
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"go/types"
	"iter"
	"log/slog"
	"maps"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/spf13/pflag"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

func loadPackage(srcDir, path string, filter func(filename string) bool) (*packages.Package, error) {
	parseFile := func(fset *token.FileSet, filename string, src []byte) (*ast.File, error) {
		if filter != nil && !filter(filename) {
			return nil, nil
		}
		return parser.ParseFile(fset, filename, src, parser.AllErrors|parser.ParseComments)
	}

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.NeedName |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedImports |
			packages.NeedDeps,
		Dir:       srcDir,
		ParseFile: parseFile,
	}, path)
	if err != nil {
		return nil, err
	}
	for _, pkg := range pkgs {
		if strings.HasSuffix(pkg.Name, "_test") {
			continue
		}

		return pkg, nil
	}
	return nil, fmt.Errorf("expected to find a single non '_test' package, got %v", pkgs)
}

func getSkipExportNames(pkg *packages.Package) map[string]struct{} {
	res := make(map[string]struct{})
	for name := range topLevelExportedObjects(pkg) {
		res[name] = struct{}{}
	}
	return res
}

func generate(
	srcDir string,
	importPath, outputPackage string,
	outputFilename string,
	goHeaderFile string,
) error {
	outputPkg, err := loadPackage(srcDir, outputPackage, func(filename string) bool {
		// Do not load a file generated by us.
		return filepath.Base(filename) != outputFilename
	})
	if err != nil {
		return err
	}

	if outputPkg.Name == "" {
		outputPkg.Name = filepath.Base(outputPkg.PkgPath)
	}

	skipExportNames := getSkipExportNames(outputPkg)

	importPkg, err := loadPackage(srcDir, importPath, nil)
	if err != nil {
		return err
	}

	importExports, err := analyzeExports(importPkg)
	if err != nil {
		return err
	}

	rawDeleg, err := buildDeleg(outputPkg, skipExportNames, importPkg, importExports, goHeaderFile)
	if err != nil {
		return err
	}

	deleg, err := imports.Process(outputFilename, rawDeleg, nil)
	if err != nil {
		return err
	}

	filename := filepath.Join(outputPackage, outputFilename)
	if err := os.MkdirAll(outputPackage, os.ModePerm); err != nil {
		return err
	}

	if err := os.WriteFile(filename, deleg, 0666); err != nil {
		return err
	}

	return nil
}

func buildDeleg(
	outputPkg *packages.Package,
	skipExportNames map[string]struct{},
	importPkg *packages.Package,
	importExports map[string]*Export,
	goHeaderFile string,
) ([]byte, error) {
	var buf bytes.Buffer

	if goHeaderFile != "" {
		goHeaderFileData, err := os.ReadFile(goHeaderFile)
		if err != nil {
			return nil, fmt.Errorf("error reading go header file: %w", err)
		}

		buf.Write(goHeaderFileData)
		buf.WriteString("\n")
	}

	// Write the package's doc string if there is any.
	for _, f := range importPkg.Syntax {
		if f.Doc != nil {
			first := true
			for line := range strings.Lines(f.Doc.Text()) {
				buf.WriteString("// ")
				if first {
					first = false
					line = strings.Replace(line, "Package "+importPkg.Name, "Package "+outputPkg.Name, 1)
				}
				buf.WriteString(strings.TrimRight(line, "\n"))
				buf.WriteString("\n")
			}
		}
	}

	buf.WriteString("package ")
	buf.WriteString(outputPkg.Name)
	buf.WriteString("\n\n")

	buf.WriteString("import (\n")
	imports := maps.Clone(importPkg.Imports)
	imports[importPkg.PkgPath] = importPkg

	for p := range imports {
		buf.WriteString(fmt.Sprintf("\t\"%s\"\n", p))
	}
	buf.WriteString(")\n\n")

	names := slices.Sorted(maps.Keys(importExports))
	for _, name := range names {
		if _, ok := skipExportNames[name]; ok {
			continue
		}

		importExport := importExports[name]
		if doc := importExport.Doc.Text(); doc != "" {
			for line := range strings.Lines(doc) {
				buf.WriteString("// ")
				buf.WriteString(strings.TrimRight(line, "\n"))
				buf.WriteString("\n")
			}
		}

		deleg, err := writeDeleg(types.NewPackage("", outputPkg.Name), importExport.TypesObject)
		if err != nil {
			return nil, err
		}

		buf.WriteString(deleg)
		buf.WriteString("\n\n")
	}

	return buf.Bytes(), nil
}

type Export struct {
	TypesObject types.Object
	Doc         *ast.CommentGroup
}

func firstNonNil[E any](e ...*E) *E {
	for _, e := range e {
		if e != nil {
			return e
		}
	}
	return nil
}

func topLevelExportedObjects(pkg *packages.Package) iter.Seq2[string, types.Object] {
	return func(yield func(string, types.Object) bool) {
		for ident, obj := range pkg.TypesInfo.Defs {
			if obj == nil {
				continue
			}

			if !obj.Exported() {
				continue
			}

			// Only include top-level definitions.
			if obj.Parent() != pkg.Types.Scope() {
				continue
			}

			if !yield(ident.Name, obj) {
				return
			}
		}
	}
}

func analyzeExports(pkg *packages.Package) (map[string]*Export, error) {
	res := make(map[string]*Export)

	// First step: Gather exports by looking at the type information.
	for name, obj := range topLevelExportedObjects(pkg) {
		res[name] = &Export{
			TypesObject: obj,
		}
	}

	// Next step: Associate the correct documentation to the exports.
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			switch d := decl.(type) {
			case *ast.FuncDecl:
				export, ok := res[d.Name.Name]
				if !ok {
					continue
				}

				export.Doc = d.Doc
			case *ast.GenDecl:
				for _, spec := range d.Specs {
					switch s := spec.(type) {
					case *ast.TypeSpec:
						export, ok := res[s.Name.Name]
						if !ok {
							continue
						}

						export.Doc = firstNonNil(s.Doc, d.Doc)
					case *ast.ValueSpec:
						for _, name := range s.Names {
							export, ok := res[name.Name]
							if !ok {
								continue
							}

							export.Doc = firstNonNil(s.Doc, d.Doc)
						}
					}
				}
			}
		}
	}

	return res, nil
}

func writeTypeDeleg(pkg *types.Package, obj *types.TypeName) (string, error) {
	var sb strings.Builder
	var alias *types.Alias
	if t, ok := obj.Type().(interface{ TypeParams() *types.TypeParamList }); ok && t.TypeParams().Len() > 0 {
		typeParams := make([]*types.TypeParam, 0, t.TypeParams().Len())
		instParams := make([]types.Type, 0, t.TypeParams().Len())

		for tp := range t.TypeParams().TypeParams() {
			aliasTypeParam := tp.Obj().Type()
			typeParams = append(typeParams, types.NewTypeParam(tp.Obj(), tp.Constraint()))
			instParams = append(instParams, aliasTypeParam)
		}

		inst, err := types.Instantiate(nil, obj.Type(), instParams, false)
		if err != nil {
			return "", err
		}

		alias = types.NewAlias(obj, inst)
		alias.SetTypeParams(typeParams)
	} else {
		alias = types.NewAlias(obj, obj.Type())
	}
	aliasType := types.NewTypeName(token.NoPos, nil, obj.Name(), alias)

	sb.WriteString(types.ObjectString(aliasType, nameRelativeTo(pkg)))
	return sb.String(), nil
}

func writeDeleg(pkg *types.Package, obj types.Object) (string, error) {
	switch obj := obj.(type) {
	case *types.Func:
		return writeFuncDeleg(pkg, obj)
	case *types.Var:
		return writeVarDeleg(pkg, obj)
	case *types.TypeName:
		return writeTypeDeleg(pkg, obj)
	default:
		return "", fmt.Errorf("unknown type %T", obj)
	}
}

func writeVarDeleg(pkg *types.Package, obj *types.Var) (string, error) {
	var sb strings.Builder
	sb.WriteString(types.ObjectString(obj, plainName))
	sb.WriteString(" = ")
	sb.WriteString(packagePrefix(obj.Pkg(), nameRelativeTo(pkg)))
	sb.WriteString(obj.Name())
	return sb.String(), nil
}

func packagePrefix(pkg *types.Package, qf types.Qualifier) string {
	if pkg == nil {
		return ""
	}
	var s string
	if qf != nil {
		s = qf(pkg)
	} else {
		s = pkg.Path()
	}
	if s != "" {
		s += "."
	}
	return s
}

func nameRelativeTo(pkg *types.Package) types.Qualifier {
	return func(other *types.Package) string {
		if pkg != nil && pkg == other {
			return "" // same package; unqualified
		}
		return other.Name()
	}
}

func plainName(*types.Package) string {
	return ""
}

func writeFuncDeleg(pkg *types.Package, obj *types.Func) (string, error) {
	var sb strings.Builder

	delegFunc := types.NewFunc(token.NoPos, pkg, obj.Name(), obj.Signature())

	sb.WriteString(types.ObjectString(delegFunc, nameRelativeTo(pkg)))
	sb.WriteString(" {\n\t")

	sig := obj.Signature()
	if sig.Results() != nil {
		sb.WriteString("return ")
	}

	sb.WriteString(packagePrefix(obj.Pkg(), nameRelativeTo(pkg)))
	sb.WriteString(obj.Name())
	sb.WriteString("(")
	if sig.Params() != nil {
		var next bool
		for v := range sig.Params().Variables() {
			if next {
				sb.WriteString(", ")
			}
			next = true
			sb.WriteString(v.Name())
		}
	}
	sb.WriteString(")")

	sb.WriteString("\n}")
	return sb.String(), nil
}

func main() {
	var (
		srcDir         string
		importPath     string
		outputPackage  string
		outputFilename string
		goHeaderFile   string
	)

	pflag.StringVar(&srcDir, "src-dir", "", "src-dir is the directory in which to run the build system's query tool\n"+
		"that provides information about the packages.\n"+
		"If src-dir is empty, the tool is run in the current directory.")
	pflag.StringVarP(&importPath, "import-path", "i", "", "Path to the package that shall be examined for creating a dropin from.")
	pflag.StringVarP(&outputPackage, "output-package", "o", "", "Path to the output package that shall be written to.")
	pflag.StringVarP(&outputFilename, "output-filename", "f", "zz_generated.dropin.go", "Name of the output file that shall be written to.")
	pflag.StringVar(&goHeaderFile, "go-header-file", "", "Go header file to include in the generated code.")

	pflag.Parse()

	if importPath == "" || outputPackage == "" || outputFilename == "" {
		pflag.Usage()
		os.Exit(1)
	}

	if err := generate(srcDir, importPath, outputPackage, outputFilename, goHeaderFile); err != nil {
		slog.Error(err.Error())
		os.Exit(1)
	}
}
